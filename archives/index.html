<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>crisman</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>首页</span></a></li><li><a href="https://github.com/"><span>Github</span></a></li><li><a href="https://juejin.im/"><span>掘金</span></a></li></ul><div class="wrapper" id="wrap"><div class="page-header"><label class="navi-button" for="navi">MENU</label><div class="background"><img src="http://pic1.win4000.com/wallpaper/1/59940cf1ad20d.jpg"></div><div class="author"><div class="head"><img src="https://wx3.sinaimg.cn/mw1024/74b4259aly1fx80hbfpfoj20dc0dc76g.jpg"></div><h3 class="name">crisman</h3><p class="signature">白发渔樵江渚上，惯看秋月春风.</p></div></div><ul class="post-list" style="max-width:800px"><li> <p class="date">2019年5月29日</p><div class="no-title"><h4 id="QB浏览器低版本推荐计划"><a href="#QB浏览器低版本推荐计划" class="headerlink" title="QB浏览器低版本推荐计划"></a>QB浏览器低版本推荐计划</h4><ul>
<li>author:<a href="mailto:crispliu@tencent.com" target="_blank" rel="noopener">crispliu@tencent.com</a></li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>该项目为一个外部调用的方法，基于jquery1.X，里面传入四个默认参数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var defaultOpts = &#123;</span><br><span class="line">                title: &apos;网页&apos;,//标题</span><br><span class="line">                minVersion:10,//最小适配ie,如果不传入默认支持到10</span><br><span class="line">                 channelNum:&quot;&quot;,//下载渠道号</span><br><span class="line">                qrHref:&apos;&apos; //二维码链接</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="开头引入"><a href="#开头引入" class="headerlink" title="开头引入"></a>开头引入</h4><p>在启用低版本推荐计划的网站中，开头引入<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">'https://stdl.qq.com/stdl/qqbrowser/floatlayer/qb-recommend-float-layer.js?'</span>+ <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="调用方法："><a href="#调用方法：" class="headerlink" title="调用方法："></a>调用方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> ![image.png](/uploads/1CF4BCE80B9F4D5CAA53F3EC03AA8E78/image.png height=&quot;330&quot; width=&quot;495&quot;)</span><br><span class="line"> </span><br><span class="line"> 传入 qrHref:&apos;&apos; //二维码链接，比如：</span><br><span class="line">```javascript</span><br><span class="line"> $.qbRecommand(&#123;title:&apos;QQ音乐&apos;,minVersion:10,channelNum:&apos;122&apos;,qrHref:&quot;https://stdl.qq.com/stdl/qqbrowser/floatlayer/img/yqqImg.png&quot;&#125;)显示如下</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/26A141C9B21F4218BDB9D205ED173962/image.png" alt="image.png"></p>
<blockquote>
<p>… … 有时间再继续补充</p>
</blockquote>
<p>MutationObserver翻译过来就是变动观察器，字面上就可以理解这是用来观察Node（节点）变化的。MutationObserver是在DOM4规范中定义的，它的前身是MutationEvent事件，该事件最初在DOM2事件规范中介绍，到来了DOM3事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。</p>
<p>MutationEvent<br>虽然MutationEvent已经被弃用，但是我们还是需要了解它，可能你会为了浏览器兼容性的问题而遇到它（万恶的浏览器兼容性）。</p>
<p>MutationEvent总共有7种事件：DOMNodeInserted、DOMNodeRemoved、DOMSubtreeModified、DOMAttrModified、<br>DOMCharacterDataModified、DOMNodeInsertedIntoDocument和DOMNodeRemovedFromDocument。</p>
<p>MutationEvent的兼容性：</p>
<p>MutationEvent在IE浏览器中最低支持到IE9<br>在webkit内核的浏览器中，不支持DOMAttrModified事件<br>IE，Edge以及Firefox浏览器下不支持DOMNodeInsertedIntoDocument和DOMNodeRemovedFromDocument事件<br>MutationEvent中的所有事件都被设计成无法取消，如果可以取消MutationEvent事件则会导致现有的DOM接口无法对文档进行改变，比如appendChild，remove等添加和删除节点的DOM操作。<br>MutationEvent中最令人诟病的就是性能以及安全性的问题，比如下面这个例子：</p>
<p>document.addEventListener(‘DOMNodeInserted’, function() {<br>    var newEl = document.createElement(‘div’);<br>    document.body.appendChild(newEl);<br>});<br>document下的所有DOM添加操作都会触发DOMNodeInserted方法，这时就会出现循环调用DOMNodeInserted方法，导致浏览器崩溃。还有就是MutationEvent是事件机制，因此会有一般事件都存在的捕获和冒泡阶段，此时如果在捕获和冒泡阶段又对DOM进行了操作会拖慢浏览器的运行。</p>
<p>另一点就是MutationEvent事件机制是同步的，也就是说每次DOM修改就会触发，修改几次就触发几次,严重降低浏览器的运行，严重时甚至导致线程崩溃</p>
<p><div id="block"></div><br>var i=0;<br>block.addEventListener(‘DOMNodeInserted’, function(e) {<br>     i++<br>});<br>block.appendChild(docuemnt.createTextNode(‘1’));<br>console.log(i)                  //1<br>block.appendChild(docuemnt.createTextNode(‘2’));<br>console.log(i)                  //2<br>block.appendChild(docuemnt.createTextNode(‘3’));<br>console.log(i)                  //3<br>再看个例子：</p>
<p><div id="block"><br>  <span id="span">Text</span><br></div><br>block.addEventListener(‘DOMNodeInserted’, function(e) {<br>     console.log(‘1’);                                  //1<br>});<br>span.appendChild(docuemnt.createTextNode(‘other Text’));<br>span元素中添加节点会触发block中的DOMNodeInserted事件，可是你只想观察block的变化，不想观察block中子节点的变化，这时你不得不在DOMNodeInserted事件中进行过滤，把对span的操作忽略掉，这无疑增加了操作的复杂性。</p>
<p>MutationObserver<br>MutationObserver的出现就是为了解决MutationEvent带来的问题。<br>先看一下MutationObserver的浏览器兼容性：</p>
<p>MutationObserver浏览器兼容性</p>
<p>我们可以看到MutationObserver在IE中最低要就是IE11，如果你的网站不需要支持IE或者只支持到IE11，那么你可以放心的使用MutationObserver，否则你可能需要用到上面提到的MutationEvent事件，当然如果你的网站还要支持IE8及以下版本，那么你只能和Mutation说拜拜了。</p>
<p>MutationObserver是一个构造器，接受一个callback参数，用来处理节点变化的回调函数，返回两个参数，mutations：节点变化记录列表（sequence<mutationrecord>），observer：构造MutationObserver对象。</mutationrecord></p>
<p>var observe = new MutationObserver(function(mutations,observer){<br>})<br>MutationObserver对象有三个方法，分别如下：</p>
<p>observe：设置观察目标，接受两个参数，target：观察目标，options：通过对象成员来设置观察选项<br>disconnect：阻止观察者观察任何改变<br>takeRecords：清空记录队列并返回里面的内容<br>关于observe方法中options参数有已下几个选项：</p>
<p>childList：设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化<br>attributes：设置true，表示观察目标属性的改变<br>characterData：设置true，表示观察目标数据的改变<br>subtree：设置为true，目标以及目标的后代改变都会观察<br>attributeOldValue：如果属性为true或者省略，则相当于设置为true，表示需要记录改变前的目标属性值，设置了attributeOldValue可以省略attributes设置<br>characterDataOldValue：如果characterData为true或省略，则相当于设置为true,表示需要记录改变之前的目标数据，设置了characterDataOldValue可以省略characterData设置<br>attributeFilter：如果不是所有的属性改变都需要被观察，并且attributes设置为true或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表<br>下表描述了MutationObserver选项与MutationEvent名称之间的对应关系：</p>
<p>MutationEvent    MutationObserver options<br>DOMNodeInserted    { childList: true, subtree: true }<br>DOMNodeRemoved    { childList: true, subtree: true }<br>DOMSubtreeModified    { childList: true, subtree: true }<br>DOMAttrModified    { attributes: true, subtree: true }<br>DOMCharacterDataModified    { characterData: true, subtree: true }<br>从上表我们也可以看出相比与MutationEvent而言MutationObserver极大地增加了灵活性，可以设置各种各样的选项来满足程序员对目标的观察。</p>
<p>我们简单看几个例子：</p>
<p><div id="target" class="block" name="target"><br>    target的第一个子节点<br>    <p><br>       <span>target的后代</span><br>    </p><br></div><br>1.callback的回调次数</p>
<p>var target=document.getElementById(‘target’);<br>var i=0<br>var observe=new MutationObserver(function (mutations,observe) {<br>    i++<br>});<br>observe.observe(target,{ childList: true});<br>target.appendChild(docuemnt.createTextNode(‘1’));<br>target.appendChild(docuemnt.createTextNode(‘2’));<br>target.appendChild(docuemnt.createTextNode(‘3’));<br>console.log(i)                //1<br>MutationObserver的callback回调函数是异步的，只有在全部DOM操作完成之后才会调用callback。</p>
<p>2.当只设置{ childList: true}时,表示观察目标子节点的变化</p>
<p>var observe=new MutationObserver(function (mutations,observe) {<br>    debugger;<br>    console.log(mutations);<br>    //observe.discount();<br>});</p>
<p>observe.observe(target,{ childList: true});<br>target.appendChild(document.createTextNode(‘新增Text节点’));   //增加节点，观察到变化<br>target.childNodes[0].remove();                                //删除节点，可以观察到<br>target.childNodes[0].textContent=’改变子节点的后代’;             //不会观察到<br>如果想要观察到子节点以及后代的变化需设置{childList: true, subtree: true}</p>
<p>attributes选项用来观察目标属性的变化，用法类似与childList,目标属性的删除添加以及修改都会被观察到。</p>
<p>3.我们需要注意的是characterData这个选项，它是用来观察CharacterData类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是CharacterData类型的节点的改变不会观察到，比如：</p>
<p>observe.observe(target,{ characterData: true, subtree: true});<br>target.childNodes[0].textContent=’改变Text节点’;              //观察到<br>target.childNodes[1].textContent=’改变p元素内容’;              //不会观察到<br>target.appendChild(document.createTextNode(‘新增Text节点’));  //不会观察到<br>target.childNodes[0].remove();                               //删除TEXT节点也不会观察到<br>我们只需要记住只有对CharacterData类型的节点的数据改变才会被characterData为true的选项所观察到。</p>
<p>4.最后关注一个特别有用的选项attributeFilter，这个选项主要是用来筛选要观察的属性，比如你只想观察目标style属性的变化，这时可以如下设置：</p>
<p>observe.observe(target,{ attributeFilter: [‘style’], subtree: true});<br>target.style=’color:red’;                      //可以观察到<br>target.removeAttribute(‘name’);                //删除name属性，无法观察到<br>disconnect方法是用来阻止观察的，当你不再想观察目标节点的变化时可以调用observe.disconnect()方法来取消观察。</p>
<p>takeRecords方法是用来取出记录队列中的记录。它的一个作用是，比如你对一个节点的操作你不想马上就做出反应，过段时间在显示改变了节点的内容。</p>
<p>var observe=new MutationObserver(function(){});<br>observe.observe(target,{ childList: true});<br>target.appendChild(document.createTextNode(‘新增Text节点’));<br>var record = observe.takeRecords();              //此时record保存了改变记录列表<br>//当调用takeRecords方法时，记录队列被清空因此不会触发MutationObserver中的callback回调方法。<br>target.appendChild(document.createElement(‘span’));<br>observe.disconnect();                            //停止对target的观察。<br>//MutationObserver中的回调函数只有一个记录，只记录了新增span元素</p>
<p>//之后可以对record进行操作<br>//…<br>MutationRecord<br>变动记录中的属性如下：</p>
<p>type：如果是属性变化，返回”attributes”，如果是一个CharacterData节点（Text节点、Comment节点）变化，返回”characterData”，节点树变化返回”childList”<br>target：返回影响改变的节点<br>addedNodes：返回添加的节点列表<br>removedNodes：返回删除的节点列表<br>previousSibling：返回分别添加或删除的节点的上一个兄弟节点，否则返回null<br>nextSibling：返回分别添加或删除的节点的下一个兄弟节点，否则返回null<br>attributeName：返回已更改属性的本地名称，否则返回null<br>attributeNamespace：返回已更改属性的名称空间，否则返回null<br>oldValue：返回值取决于type。对于”attributes”，它是更改之前的属性的值。对于”characterData”，它是改变之前节点的数据。对于”childList”，它是null<br>其中 type、target这两个属性不管是哪种观察方式都会有返回值，其他属性返回值与观察方式有关，比如只有当attributeOldValue或者characterDataOldValue为true时oldValue才有返回值，只有改变属性时，attributeName才有返回值等。</p>
</div><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>10 Minutes</li><li><i class="icon icon-category"></i></li></ul></li><li> <p class="date">2018年11月12日</p><h4 class="title"><a href="/2018/11/12/xiaoaojianghu/">笑傲江湖</a></h4><div class="excerpt"><p>“你瞧这些白云聚了又散，散了又聚，人生离合，亦复如斯。” ——金庸</p>
<p><img src="http://wx4.sinaimg.cn/large/611e0f66ly1fwqjcsnhldj20m80er7dm.jpg" alt="pic"></p></div><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>2 Minutes</li><li><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a><span class="category-list-count">1</span></li></ul></li></ul></li><li> <p class="date">2018年10月18日</p><h4 class="title"><a href="/2018/10/18/vuex-router-one/">vuex路由刷新数据重置和F5刷新数据保持</a></h4><div class="excerpt"><p>项目中遇到的问题，记录一下。</p>
<p><img src="https://blog-10039692.file.myqcloud.com/1504751009021_60_1504751009399.jpeg" alt="pic"></p></div><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>21 Minutes</li><li><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">front-end</a><span class="category-list-count">9</span></li></ul></li></ul></li><li> <p class="date">2018年1月2日</p><h4 class="title"><a href="/2018/01/02/html5-meta/">html5 - meta/link 标签详解</a></h4><div class="excerpt"><p>html5 meta/link 标签详解。</p></div><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>18 Minutes</li><li><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">front-end</a><span class="category-list-count">9</span></li></ul></li></ul></li><li> <p class="date">2017年11月20日</p><h4 class="title"><a href="/2017/11/20/promise/">关于 promise</a></h4><div class="excerpt"><p><a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/?qq-pf-to=pcqq.c2c" target="_blank" rel="noopener">转自：[翻译] We have a problem with promises</a></p>
<blockquote>
<p>Q: 下面的四种 promises 的区别是什么</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(function () &#123;</span><br><span class="line">  return doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(function () &#123;</span><br><span class="line">  doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我尝试分析这道题的答案时，看了一半就楞(meng)住(bi)了，深深的怀疑我是否看过《你不知道的 JavaScript》中关于<code>异步和性能</code>的那章，看完这篇文章，有豁然开朗的感觉。</p>
</blockquote></div><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>48 Minutes</li><li><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">front-end</a><span class="category-list-count">9</span></li></ul></li></ul></li></ul><ul class="pagination"><li class="current"><a>1</a></li><li class="link"><a href="/archives/page/2/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/icrisman" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/p/1005051957963162/home" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.douban.com/people/72740604/statuses" title="Douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 crisman<br><!--small POWER BY --><!--  a(href="https://hexo.io", target="_blank") HEXO--><!--if theme.copyright.laughing//small , THEME BY 
  //a(href="https://github.com/BoizZ/hexo-theme-laughing", target="_blank") LAUGHING--></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>