<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>结合promise对原生fetch的两个then用法理解 - crisman</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>首页</span></a></li><li><a href="https://github.com/"><span>Github</span></a></li><li><a href="https://juejin.im/"><span>掘金</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">结合promise对原生fetch的两个then用法理解</h1><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>17 Minutes</li><li><i class="icon icon-calendar"></i>2018年3月30日</li></ul></div></div><div class="article-content" style="max-width:800px"><p>前言：该问题是由于看到fetch的then方法的使用，产生的疑问，在深入了解并记录对promise的个人理解</p>
<p>首先看一下fetch请求使用案例：</p>
<p>案例效果：点击页面按钮，请求当前目录下的arr.txt里面的内容</p>
<p>疑问地方：</p>
<p>1. fetch为什么可以使用then？（个人理解then方法是定义在原型对象<code>Promise.prototype</code>上的）</p>
<p>2. 为什么使用两次then才能取出数据？（重点疑惑是这里，疑惑第二个then没有进行其他操作，只是将上一个then的返回值进行输出，就可以获取到arr.txt的数据）<br><a id="more"></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">"btn1"</span>); </span><br><span class="line">    oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"arr.txt"</span>; <span class="comment">//let url = "json.txt";  </span></span><br><span class="line">        fetch(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">/* res.text 返回的是一个纯文本  是一个promise对象</span></span><br><span class="line"><span class="comment">            res.json 返回的是一个对象（json/array）  是一个promise对象</span></span><br><span class="line"><span class="comment">            response是只能被读取一次的,console.log取一次，return取一次，会报错 */</span> <span class="keyword">let</span> resdata = res.json();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">0</span>,resdata); <span class="comment">//打印：\[\[PromiseStatus\]\]: "resolved" //return res.text();</span></span><br><span class="line">            <span class="keyword">return</span> resdata; <span class="comment">//返回值是一个新的promise对象，状态为resolved,所以执行then  </span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123; <span class="comment">//上一个then返回值是Promise对象（即有异步操作），等待该Promise对象的状态发生变化,then才会被调用 console.log(1，data)&#125;,data2=&gt;&#123;</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>,data2)&#125;    </span><br><span class="line">        ).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">4</span>,err);    </span><br><span class="line">        &#125;);</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><strong> 所以去查询了then的用法，查询到阮一峰写了关于promise的文章<a href="http://es6.ruanyifeng.com/?search=fecth&amp;x=0&amp;y=0#docs/promise，里面介绍到promise和then的具体用法：" target="_blank" rel="noopener">http://es6.ruanyifeng.com/?search=fecth&amp;x=0&amp;y=0#docs/promise，里面介绍到promise和then的具体用法：</a></strong></p>
<p><strong>看到一个案例：任务执行顺序问题：（中间插曲）</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line"></span><br><span class="line">resolve();</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>1.  Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。</p>
<p>2. 当请求到数据后，执行resolve方法，改变promise状态为resolved，使<code>then</code>方法执行第一个回调函数，第一个函数参数为resolve传递出来的数据，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。为啥最后执行呢？</p>
<p>　　我又去查询下<a href="https://www.cnblogs.com/hanguidong/p/9483460.html" target="_blank" rel="noopener">JavaScript 运行机制详解</a>：也是理解与阮一峰的：</p>
<p>　　理解出一条：先执行主线程（同步任务放置在主线程），主线程执行完，系统去读取任务队列中（异步任务放置在任务队列），js的运行机制是这样设定的。嗯，没毛病</p>
<p> 3. 意思就是resolve是异步任务，放置在任务队列中，console.log(“HI”)  是同步任务，放置在主程序中，当主程序中的执行完，才会去查看任务队列。</p>
<p>执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolved&lt;br&gt;&lt;br&gt;&lt;strong&gt;继续介绍then用法：&lt;br&gt;&lt;/strong&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p>
<p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法</p>
<p><strong>这句话跟fetch的用法是一样的由于then的返回值是一个promise实例，可以采用的是链式写法，</strong></p>
<blockquote>
<p><code>还是但是fetch和promise还是没啥关系？&lt;br&gt;当我又看到一个案例：为啥getJSON（）这个可以使用then,应该是new promise才可以使用then吗?我才明白getJSON是封装的一个函数，返回值是new promise，所以执行getJSON()可以使用then的方法</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123; <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123; <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;到现在才明白fetch（）其实就是封装了的promise的函数，返回值是promise的实例，所以才能调用then用法，所以说，fetch（）其实就是promise的实例。&lt;br&gt;&lt;/span&gt;&lt;/strong&gt;回到最初的疑问？</code></p>
</blockquote>
<p>1. fetch为什么可以使用then？（个人理解then方法是定义在原型对象<code>Promise.prototype</code>上的）</p>
<p>2. 为什么使用两次then才能取出数据？（重点疑惑是这里，疑惑第二个then没有进行其他操作，只是将上一个then的返回值进行输出，就可以获取到arr.txt的数据）</p>
<blockquote>
<p><code>&lt;strong&gt;为什么使用两次then才能正常取出数据？我将最初的案例运行：查看第一个then的返回值是啥？&lt;br&gt;&lt;/strong&gt;</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">"btn1"</span>); </span><br><span class="line">    oBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> url = <span class="string">"arr.txt"</span>; <span class="comment">//let url = "json.txt";</span></span><br><span class="line"> fetch(url).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123; <span class="comment">/* res.text 返回的是一个纯文本  是一个promise对象</span></span><br><span class="line"><span class="comment">            res.json 返回的是一个对象（json/array）  是一个promise对象</span></span><br><span class="line"><span class="comment">            response是只能被读取一次的,console.log取一次，return取一次，会报错 */</span> <span class="keyword">let</span> resdata = res.json();</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">0</span>,resdata); <span class="comment">//打印：\[\[PromiseStatus\]\]: "resolved" //return res.text();</span></span><br><span class="line">            <span class="keyword">return</span> resdata; <span class="comment">//返回值是一个新的promise对象，状态为resolved,所以执行then  </span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　<span class="comment">//　Promise  </span></span><br><span class="line">　　　　　　　　　<span class="comment">//　\_\_proto\_\_  </span></span><br><span class="line">　　　　　　　　　<span class="comment">//:  </span></span><br><span class="line">　　　　　　　　　<span class="comment">//Promise  </span></span><br><span class="line">　　　　　　　　　<span class="comment">//\[\[PromiseStatus\]\]:"resolved"  </span></span><br><span class="line">　　　　　　　　　<span class="comment">//\[\[PromiseValue\]\]:Array\[3\]</span></span><br><span class="line"></span><br><span class="line"> &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123; <span class="comment">//上一个then返回值是Promise对象（即有异步操作），等待该Promise对象的状态发生变化,then才会被调用</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>，data)&#125;,data2=&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">2</span>,data2)&#125;    </span><br><span class="line">        ).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">4</span>,err);    </span><br><span class="line">        &#125;);</span><br><span class="line">            </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;strong&gt;解释两次then用法：&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;第一次then用法&lt;/strong&gt;：then是根据promise的状态变化而执行的回调函数，promise的状态变化由resolve()函数决定（取到数据执行resolve），then的参数为resolve函数传递出来的数据，&lt;br&gt;直接输出res是一个对象不是我们需要的数据，使用res.json()或者res.test()获取到我们需要的数据。&lt;br&gt;res.json（）/res.text（）获取到的是一个新的promise实例，arr.txt的值在[[[PromiseValue]]里面，但是直接取是取不出来的。没有方法取出来，&lt;br&gt;Promise的设计文档中说了，[[PromiseValue]]是个内部变量，外部无法得到，只能在then中获取。所以就会用到第二次then了</code></p>
</blockquote>
<blockquote>
<p><code>&lt;strong&gt;第二次then用法：就是怎么将&lt;/strong&gt;[[[PromiseValue]]里面的数据取出来</code></p>
</blockquote>
<blockquote>
<p><code>现在就重点理解下[[[PromiseValue]]这个怎么获取到的？&lt;`</code>br<code></code>&gt;代码中的resolve（）就是说明resolve内部是怎么运行的，改变promise的状态，给PromiseValue复制，`</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于描述思维的代码 */</span> executor(resolve, reject) &#123;</span><br><span class="line">    ...</span><br><span class="line">    resolve(value);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">resolve(value) &#123;</span><br><span class="line">    PromiseStatus = <span class="string">'fulfilled'</span>;</span><br><span class="line">    PromiseValue = value;</span><br><span class="line">    ... <span class="comment">// 接着调用回调链中的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;strong&gt;这句话解决了第二个then的用法：&lt;br&gt;&lt;/strong&gt;onFulfilled(value)和onRejected(reason)：&lt;strong&gt;参数value和reason的实参都是PromiseValue&lt;/strong&gt;。这句话是说then的回调函数参数使用的都是&lt;strong&gt;PromiseValue，&lt;/strong&gt;所以直接输出就会获取到PromiseValue的值&lt;br&gt;&lt;br&gt;&lt;strong&gt;这里有一点值得注意：第一个then 的return返回值是一个promise实例对象，所以回调链转交给了新的实例对象，第二个then的回调函数参数为为&lt;/strong&gt;&lt;strong&gt;PromiseValue的值，当返回值不是对象时，返回值是数据类型时，会将该返回值&lt;/strong&gt;
&lt;strong&gt;赋值给PromiseValue，供下次的then函数使用&lt;br&gt;&lt;/strong&gt;
如果onFulfilled(value)和onRejected(reason)这两个回调函数中return返回值不是一个Promise的对象，（then）
那么这个返回值会被赋给PromiseValue，并在下一个then()的onFulfilled(value)和onRejected(reason)中做为实参使用。
但如果这个返回值是一个Promise的对象，那么剩下的由then()构造的回调链会转交给新的Promise对象并完成调用。
&lt;strong&gt;回调链是啥？？&lt;br&gt;&lt;strong&gt;then(onFulfilled, onRejected)：&lt;/strong&gt;这个方法实际上是把onFulfilled()函数和onRejected()函数添加到Promise对象的回调链中。&lt;br&gt;回调链就像一个由函数组构成的队列，每一组函数都是由至少一个函数构成（onFulfilled() 或者 onRejected() 或者 onFulfilled() 和 onRejected()）。&lt;br&gt;当resolve()或者reject()方法执行的时候，回调链中的回调函数会根据PromiseStatus的状态情况而被依次调用。&lt;br&gt;&lt;/strong&gt;</code></p>
</blockquote>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">4</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">4</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjwa3hucg0000uwp4ylp02twd" data-title="结合promise对原生fetch的两个then用法理解" data-url="http://yoursite.com/2018/03/30/fetch-then/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  //ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2018/10/18/vuex-router-one/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2018/01/02/html5-meta/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/icrisman" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/p/1005051957963162/home" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.douban.com/people/72740604/statuses" title="Douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 crisman<br><!--small POWER BY --><!--  a(href="https://hexo.io", target="_blank") HEXO--><!--if theme.copyright.laughing//small , THEME BY 
  //a(href="https://github.com/BoizZ/hexo-theme-laughing", target="_blank") LAUGHING--></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>