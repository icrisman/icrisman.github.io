<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>ES6 学习笔记 (ing) - crisman</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/"><span>Github</span></a></li><li><a href="https://www.v2ex.com/"><span>V2EX</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">ES6 学习笔记 (ing)</h1><ul class="meta"><li><i class="icon icon-author"></i>crisman</li><li><i class="icon icon-clock"></i>38 Minutes</li><li><i class="icon icon-calendar"></i>2016年10月14日</li></ul></div></div><div class="article-content" style="max-width:800px"><blockquote>
<p>我只是一个简单的学习笔记。</p>
</blockquote>
<p>learn from this book:  <a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript 6 入门》</a> by 阮一峰</p>
<a id="more"></a>
<!-- toc -->
<h2 id="0-发展历史"><a href="#0-发展历史" class="headerlink" title="0. 发展历史"></a>0. 发展历史</h2><ul>
<li>1996.11，ECMAScript 1.0发布</li>
<li>1998.6，ECMAScript 2.0发布</li>
<li>1999.12，ECMAScript 3.0发布</li>
<li>2000~2007.10，ECMAScript 4.0草案发布，最终因分歧较大未发布正式版本</li>
<li>2009.12，ECMAScript 5.0</li>
<li>2011.6，ECMAScript 5.1发布</li>
<li>2015.6，ES2015（《ECMAScript 2015标准》）发布</li>
<li>2016.6，ES2016（《ECMAScript 2016标准》）发布</li>
</ul>
<blockquote>
<p>ES6既是一个历史名词，也是一个泛指，含义是5.1版以后的JavaScript的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015则是正式名称，特指该年发布的正式版本的语言标准。</p>
</blockquote>
<blockquote>
<p>本书中提到“ES6”的地方，一般是指ES2015标准，但有时也是泛指“下一代JavaScript语言”。</p>
</blockquote>
<p>ECMAScript 与 Javascript 的区别是：前者是后者的规格，后者是前者的一种实现。</p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><h3 id="node-推荐使用nvm管理node版本"><a href="#node-推荐使用nvm管理node版本" class="headerlink" title="node (推荐使用nvm管理node版本)"></a>node (推荐使用nvm管理node版本)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">## 安装nvm，&lt;version number&gt;需要用版本号替换，目前是v0.32.0</span><br><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/&lt;version number&gt;/install.sh | bash</span><br><span class="line"></span><br><span class="line">## 激活nvm</span><br><span class="line">$ source ~/.nvm/nvm.sh</span><br><span class="line"></span><br><span class="line">## 列出远程node版本</span><br><span class="line">$ nvm ls-remote</span><br><span class="line"></span><br><span class="line">## 安装指定版本的node</span><br><span class="line">$ nvm install v4.1.2</span><br><span class="line"></span><br><span class="line">## 切换到指定版本</span><br><span class="line">$ nvm use v4.1.2</span><br><span class="line"></span><br><span class="line">## 查看当前已安装的node版本</span><br><span class="line">$ nvm ls</span><br><span class="line"></span><br><span class="line">## 设置指定版本为默认的node版本</span><br><span class="line">$ nvm alias default stable</span><br><span class="line"></span><br><span class="line">## 查看当前node版本</span><br><span class="line">$ node -v</span><br><span class="line"></span><br><span class="line">## 查看node安装目录</span><br><span class="line">$ which node</span><br><span class="line"></span><br><span class="line">## npm安装的全局目录</span><br><span class="line">$ npm config get prefix</span><br><span class="line">$ npm config set prefix /usr/local/</span><br></pre></td></tr></table></figure>
<h3 id="Babel转码工具"><a href="#Babel转码工具" class="headerlink" title="Babel转码工具"></a>Babel转码工具</h3><p>由于浏览器暂不支持 es6 的解析，所以需要使用Babel，第一步是添加配置<br>有以下两种方式:</p>
<ol>
<li><p>在项目根目录添加配置文件 <code>.babelrc</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 设定转码规则</span><br><span class="line">    &quot;presets&quot;: [&quot;es2015&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>package.json</code> 添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel&quot;: &#123;</span><br><span class="line"> 　　&quot;presets&quot;: [&quot;es2015&quot;, &quot;stage-2&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="http://babeljs.io/repl/" target="_blank" rel="noopener">你可以在这里测试转码效果</a></p>
<blockquote>
<p><a href="http://babeljs.io/docs/setup/#installation" target="_blank" rel="noopener">Babel官网</a> 推荐将 babel-cli 安装在项目本地，原因有二：</p>
<ul>
<li>Different projects on the same machine can depend on different versions of Babel allowing you to update one at a time.</li>
<li>It means you do not have an implicit dependency on the environment you are working in. Making your project far more portable and easier to setup.</li>
</ul>
</blockquote>
<ul>
<li>一台机器上的不同项目可能会基于不同版本的 Babel ，这样允许你一次升级一个项目，不会互相影响</li>
<li>这意味着在你工作的环境下没有含义不明的依赖。使你的项目更轻便、更容易安装。</li>
</ul>
<p><a href="http://babeljs.io/docs/setup/#installation" target="_blank" rel="noopener">[这里还有其它的使用方式]</a></p>
<h2 id="2-主要内容"><a href="#2-主要内容" class="headerlink" title="2. 主要内容"></a>2. 主要内容</h2><h3 id="数据类型变化"><a href="#数据类型变化" class="headerlink" title="数据类型变化"></a>数据类型变化</h3><p>JS 中的数据类型有：undefined null String Number Boolean Object</p>
<h4 id="新增-symbol-类型"><a href="#新增-symbol-类型" class="headerlink" title="新增 symbol 类型"></a>新增 symbol 类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个新的symbol，它的值与其它任何值皆不相等：</span><br><span class="line">var mySymbol = Symbol()</span><br><span class="line"></span><br><span class="line">// 创建一个独一无二的symbol：</span><br><span class="line">var isMoving = Symbol(&quot;isMoving&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三种获取 Symbol 的方式</p>
<ol>
<li>Symbol()</li>
<li>Symbol.for(string)</li>
<li>使用标准定义的 Symbol，如 <code>Symbol.iterator</code></li>
</ol>
</li>
<li><p>tips</p>
<ul>
<li>symbol 不能被自动转为字符串或数字，但可以转为 boolean；</li>
<li>symbol 作为属性时不能被 for…in、 <code>Object.keys()</code>等遍历到，可以使用<code>Object.getOwnPropertySymbols(obj)</code> 或<code>Reflect.ownKeys(obj)</code>，前者返回对象的 symbol 键，后者返回所有字符串键和 symbol 键；</li>
<li>Symbol.keyFor(s1) 返回 symbol s1的 key 值</li>
</ul>
</li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><ul>
<li>Object.defineProperty()</li>
<li>Object.freeze()</li>
<li>Object.seal()</li>
</ul>
<h3 id="语法变化"><a href="#语法变化" class="headerlink" title="语法变化"></a>语法变化</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><ul>
<li><p>let：声明变量，类似var。与var区别如下：</p>
<ul>
<li><strong>块级作用域</strong>。只在let所在代码块内有效，for语句的计数器很适合用let声明；</li>
<li><strong>先声明后使用</strong>。不存在变量提升；暂时性死区，在一个作用域内所有变量都需要先声明后使用，否则会导致ReferenceError；</li>
<li><strong>不允许重复声明</strong>；</li>
</ul>
</li>
<li><p>const：声明常量。</p>
<ul>
<li>除 <strong>只读</strong> 外，其它特性与let类似。</li>
<li><p>const定义引用类型时，表示的是地址可读，如对象或数组，其值仍然可修改，如果要冻结，可使用<code>Object.freeze()</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const foo = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">// 常规模式时，下面一行不起作用；</span><br><span class="line">// 严格模式时，该行会报错</span><br><span class="line">foo.prop = 123;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>class</p>
</li>
</ul>
<p>通常我们这样实现一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Circle(radius) &#123;</span><br><span class="line">    this.radius = radius;</span><br><span class="line">    Circle.circlesMade++;</span><br><span class="line">&#125;</span><br><span class="line">Circle.draw = function draw(circle, canvas) &#123; /* Canvas绘制代码 */ &#125;</span><br><span class="line">Object.defineProperty(Circle, &quot;circlesMade&quot;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        return !this._count ? 0 : this._count;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(val) &#123;</span><br><span class="line">        this._count = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Circle.prototype = &#123;</span><br><span class="line">    area() &#123;</span><br><span class="line">        return Math.pow(this.radius, 2) * Math.PI;</span><br><span class="line">    &#125;,</span><br><span class="line">    get radius() &#123;</span><br><span class="line">        return this._radius;</span><br><span class="line">    &#125;,</span><br><span class="line">    set radius(radius) &#123;</span><br><span class="line">        if (!Number.isInteger(radius))</span><br><span class="line">            throw new Error(&quot;圆的半径必须为整数。&quot;);</span><br><span class="line">        this._radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，新增了<code>class</code> 关键字用来声明一个类，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Circle &#123;</span><br><span class="line">    constructor(radius) &#123;</span><br><span class="line">        this.radius = radius;</span><br><span class="line">        Circle.circlesMade++;</span><br><span class="line">    &#125;;</span><br><span class="line">    static draw(circle, canvas) &#123;</span><br><span class="line">        // Canvas绘制代码</span><br><span class="line">    &#125;;</span><br><span class="line">    static get circlesMade() &#123;</span><br><span class="line">        return !this._count ? 0 : this._count;</span><br><span class="line">    &#125;;</span><br><span class="line">    static set circlesMade(val) &#123;</span><br><span class="line">        this._count = val;</span><br><span class="line">    &#125;;</span><br><span class="line">    area() &#123;</span><br><span class="line">        return Math.pow(this.radius, 2) * Math.PI;</span><br><span class="line">    &#125;;</span><br><span class="line">    get radius() &#123;</span><br><span class="line">        return this._radius;</span><br><span class="line">    &#125;;</span><br><span class="line">    set radius(radius) &#123;</span><br><span class="line">        if (!Number.isInteger(radius))</span><br><span class="line">            throw new Error(&quot;圆的半径必须为整数。&quot;);</span><br><span class="line">        this._radius = radius;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，还增加了<code>extends</code>来实现继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">    get color() &#123;</span><br><span class="line">        return this._color;</span><br><span class="line">    &#125;</span><br><span class="line">    set color(c) &#123;</span><br><span class="line">        this._color = parseColorAsRGB(c);</span><br><span class="line">        this.markChanged();  // 稍后重绘Canvas</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle extends Shape &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ES5中，var或function定义的全局变量与顶层对象(window/global)的属性等价。<br>ES6中，let、const、class定义的全局变量不再跟顶层对象有关联。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">// 如果在Node的REPL环境，可以写成global.a</span><br><span class="line">// 或者采用通用方法，写成this.a</span><br><span class="line">window.a // 1</span><br><span class="line"></span><br><span class="line">let b = 1;</span><br><span class="line">window.b // undefined</span><br></pre></td></tr></table></figure>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><ul>
<li><p>基础使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;world&apos;</span><br><span class="line">var result = `hello $&#123;str&#125;` // &apos;hello world&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签模板 tagged templates<br>语法：模板字符串开始的反撇号前附加一个额外的标签，可以是标识符、属性值或方法调用等任何 ES6的成员表达式或调用表达式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var message = SaferHTML`&lt;p&gt;$&#123;bonk.sender&#125; 向你示好。&lt;/p&gt;`;</span><br><span class="line"></span><br><span class="line">// 等效于</span><br><span class="line">var message = SaferHTML(templateData, bonk.sender);</span><br><span class="line"></span><br><span class="line">// SaferHTML是一个普通的函数，它可以是这样：</span><br><span class="line">function SaferHTML(templateData) &#123;</span><br><span class="line">  var s = templateData[0];</span><br><span class="line">  for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    var arg = String(arguments[i]);</span><br><span class="line"></span><br><span class="line">    // 转义占位符中的特殊字符。</span><br><span class="line">    s += arg.replace(/&amp;/g, &quot;&amp;&quot;)</span><br><span class="line">            .replace(/&lt;/g, &quot;&lt;&quot;)</span><br><span class="line">            .replace(/&lt;/g, &quot;&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    // 不转义模板中的特殊字符。</span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不定参数、默认参数"><a href="#不定参数、默认参数" class="headerlink" title="不定参数、默认参数"></a>不定参数、默认参数</h4><ul>
<li><p>不定参数</p>
<ol>
<li>使用 <code>arguments</code>解决</li>
<li><p>使用 <code>...</code> 展开运算符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// needles 是 haystack 后面所有参数组成的数组</span><br><span class="line">function containsAll(haystack, ...needles) &#123;</span><br><span class="line">    for (var needle of needles) &#123;</span><br><span class="line">        if (haystack.indexOf(needle) === -1) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>默认参数<br>形参部分通过赋值语句可以设置默认参数，从左至右依次赋值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getItemById (id = 0) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        id,</span><br><span class="line">        name: &apos;moly&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><ul>
<li><p>对象赋值模式</p>
<p>  被解构的值需要被强制转换为对象。因此 null 和 undefined 不能被解构。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;a, b&#125; = &#123;a: 1, b: 2&#125; // a: 1, b: 2</span><br><span class="line">var &#123;a: name&#125; = &#123;a: &apos;moly&apos;&#125; // name: moly</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组赋值模式</p>
<p>  被解构的值一定要包含一个迭代器。同样 null 和 undefined 不可迭代。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var [a, b] = [1, 2, 3]</span><br><span class="line">var [head, ...tail] = [1, 2, 3, 4]; // head: 1,  tail: [2, 3, 4]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用途总结</p>
<ul>
<li><p>交换变量的值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数定义</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3])</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数参数的默认值</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">    async = true,</span><br><span class="line">    beforeSend = function () &#123;&#125;,</span><br><span class="line">    cache = true,</span><br><span class="line">    complete = function () &#123;&#125;,</span><br><span class="line">    crossDomain = false,</span><br><span class="line">    global = true,</span><br><span class="line">    // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br><span class="line">// 避免了 var foo = config.foo || &apos;default foo&apos; 这样的语句</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- 遍历Map

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var map = new Map()</span><br><span class="line">map.set(&apos;first&apos;, &apos;hello&apos;)</span><br><span class="line">map.set(&apos;second&apos;, &apos;world&apos;)</span><br><span class="line">// [key] 或 [, value] 可以只获取key或只获取value</span><br><span class="line">for (let [key, value] of map) &#123;</span><br><span class="line">    console.log(key + &quot; is &quot; + value)</span><br><span class="line">&#125;</span><br><span class="line">// first is hello</span><br><span class="line">// second is world</span><br></pre></td></tr></table></figure>

- 多重返回值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 数组形式</span><br><span class="line">function returnMultipleValues() &#123;</span><br><span class="line">    return [1, 2]</span><br><span class="line">&#125;</span><br><span class="line">var [foo, bar] = returnMultipleValues()</span><br><span class="line"></span><br><span class="line">// 对象形式</span><br><span class="line">function returnMultipleValues() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        foo: 1,</span><br><span class="line">        bar: 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var &#123;foo, bar&#125; = returnMultipleValues()</span><br></pre></td></tr></table></figure>

- 输入模块的指定方法

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123;SourceMapConsumer, SourceNode&#125; = require(&quot;source-map&quot;);</span><br><span class="line">// 类似 `import` 的语法</span><br></pre></td></tr></table></figure>
</code></pre><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var sum = (a, b) =&gt; a + b</span><br><span class="line">sum(2, 3) // 5</span><br></pre></td></tr></table></figure>
<ul>
<li>箭头函数没有自己的 this 值，它的 this 继承自外围作用域</li>
<li>箭头函数没有自己的 arguments 值，可以使用不定参数和默认参数来实现</li>
</ul>
<p>详细的语法参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">这里</a></p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><ul>
<li><p>最初我们使用普通的 for 循环遍历数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3]</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES5之后，使用 Array.prototype.forEach</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (val) &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>forEach 的缺点： 不能使用 break 中断循环；不能使用 return 返回外层。</p>
<ul>
<li>或许也可以试一下 for-in 循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var index in arr) &#123;</span><br><span class="line">    console.log(arr[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>for-in 的缺点：循环变量 index 不是数字而是字符串；遍历的不仅包含数组元素还可能包含自定义属性，如 arr.name；更甚，遍历结果可能按随机顺序 orz！</p>
<p>其实 for-in 是为遍历对象而设计的。</p>
<ul>
<li>请使用 for-of 循环吧<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var val of arr) &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>简洁而正确，可正确响应 <code>break</code>、<code>continue</code>、<code>return</code>。<br>它为遍历各种集合而设计，实际是调用集合的<code>[Symbol.iterator]()</code>方法。<br>但它也有缺点，那就是无法获取索引值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 因为jQuery对象与数组相似，可以为其添加与数组一致的迭代器方法</span><br><span class="line">jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]</span><br><span class="line">// 这样就可以使用 for-of 遍历 jQuery 对象了</span><br><span class="line">for (var $item of $(&apos;div&apos;)) &#123;</span><br><span class="line">    console.log($item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>Array/Set/Map 都有一个迭代器方法，也就是<code>[Symbol.iterator]()</code>。可以为任何对象添加这个方法，拥有这个方法的对象被称为<code>可迭代的</code>。</p>
<p>迭代器是一个拥有 <code>next</code> 方法的对象，遍历这个对象时，每个循环都调用 next 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var zeroesForeverIterator = &#123;</span><br><span class="line">    [Symbol.iterator] () &#123;</span><br><span class="line">        return this</span><br><span class="line">    &#125;,</span><br><span class="line">    next () &#123;</span><br><span class="line">        return &#123;done: false, value: 0&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器是一种特殊的函数，它与函数有以下不同：</p>
<ol>
<li>使用 <code>function*</code> 声明；</li>
<li>函数内部可以写无数个 <code>yield</code> 语句，类似<code>return</code>；</li>
<li>调用生成器函数，返回一个暂停的生成器对象；</li>
<li>每当调用生成器对象的 <code>.next()</code> 方法，函数将开启运行直到下一个<code>yield</code>语句，并返回对象 <code>{value: &#39;yield 后的值&#39;, done: false}</code>，执行到最后一个 yield 时，返回对象的 done 值为 true。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function* quips (name) &#123;</span><br><span class="line">    yield &apos;this&apos;</span><br><span class="line">    yield &apos;is&apos;</span><br><span class="line">    yield name + &apos;\&apos;s&apos;</span><br><span class="line">    yield &apos;generator&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var q = quips(&apos;celine&apos;)</span><br><span class="line">q.next()  // &#123;value: &apos;this&apos;, done: false&#125;</span><br><span class="line">q.next()  // &#123;value: &apos;is&apos;, done: false&#125;</span><br><span class="line">q.next()  // &#123;value: &apos;celine&apos;s&apos;, done: false&#125;</span><br><span class="line">q.next()  // &#123;value: &apos;generator&apos;, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>这个奇怪的东西是用来干嘛的呢？</p>
<p>假如我想实现一个 range 迭代器，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 应该弹出三次 &quot;ding&quot;</span><br><span class="line">for (var value of range(0, 3)) &#123;</span><br><span class="line">    alert(&quot;Ding! at floor #&quot; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法一：使用 ES6的 class 实现</span><br><span class="line">class RangeIterator &#123;</span><br><span class="line">  constructor(start, stop) &#123;</span><br><span class="line">    this.value = start;</span><br><span class="line">    this.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [Symbol.iterator]() &#123; return this; &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    var value = this.value;</span><br><span class="line">    if (value &lt; this.stop) &#123;</span><br><span class="line">      this.value++;</span><br><span class="line">      return &#123;done: false, value: value&#125;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return &#123;done: true, value: undefined&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回一个新的迭代器，可以从start到stop计数。</span><br><span class="line">function range(start, stop) &#123;</span><br><span class="line">  return new RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法二：用生成器</span><br><span class="line">function* range (start, stop) &#123;</span><br><span class="line">    for (var i = start; i &lt; stop; i++) &#123;</span><br><span class="line">        yield i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这么简洁明了，我和我的小伙伴都惊呆了！</p>
<blockquote>
<p>生成器是迭代器。</p>
</blockquote>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ul>
<li>es6中，一个js 文件是一个模块，默认为严格模式；</li>
<li>在模块中可以使用 import 来引入模块，用 export 来导出模块。</li>
</ul>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h4></div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/front-end/">front-end</a><span class="category-list-count">9</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cjoi7vonx0001c2p4q662r9g5" data-title="ES6 学习笔记 (ing)" data-url="http://yoursite.com/2016/10/14/es6-learning-notes/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  //ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/03/31/layout/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2016/08/30/front-end-spec/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/icrisman" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://weibo.com/p/1005051957963162/home" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.douban.com/people/72740604/statuses" title="Douban" target="_blank"><i class="icon icon-douban"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2018 crisman<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>